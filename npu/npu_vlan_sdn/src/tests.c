#include "lib/include/helpers.h"
#include "lib/include/mac.h"

#include "tests.h"
#include "stages.h"
#include "table.h"

struct io_fn io = {
	.rx = mac_rx,
	.tx = mac_tx
};

void init_vlan_table(void)
{
	struct vlan_node_item node1_0 =
		{ .port = 0, .mode = NO_TAG };

	struct vlan_node_item node1_2 =
		{ .port = 5, .mode = NEED_TAG };

	struct vlan_node_item node1_1 =
		{ .port = 4, .mode = NEED_TAG };


	struct vlan_node_item node2_0 =
		{ .port = 1, .mode = NO_TAG };

	struct vlan_node_item node2_1 =
		{ .port = 3, .mode = NO_TAG };

	struct vlan_node_item node2_2 =
		{ .port = 4, .mode = NEED_TAG };

	struct vlan_node_item node2_3 =
		{ .port = 5, .mode = NEED_TAG };


	struct vlan_node_item node_off_0 =
		{ .port = 2, .mode = NO_TAG };

	struct vlan_node_item node_off_1 =
		{ .port = 6, .mode = NO_TAG };


	struct vlan_table *tbl = vlan_table_mmap();

	tbl->nodes[1].items[0] = node1_0;
	tbl->nodes[1].items[1] = node1_1;
	tbl->nodes[1].items[2] = node1_2;
	tbl->nodes[1].len = 3;

	tbl->nodes[2].items[0] = node2_0;
	tbl->nodes[2].items[1] = node2_1;
	tbl->nodes[2].items[2] = node2_2;
	tbl->nodes[2].items[3] = node2_3;
	tbl->nodes[2].len = 4;

	tbl->nodes[VLAN_NONE].items[0] = node_off_0;
	tbl->nodes[VLAN_NONE].items[1] = node_off_1;
	tbl->nodes[VLAN_NONE].len = 2;
}

int test_broadcast(struct output_frame_context *out_frames,
				   struct output_frame_context *ctrl_frame)
{
	static uint8_t frame1[] = {
			0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0x08, 0x00, // end of ethernet header
			0x45, 0xc0, 0x00, 0x3c, 0xbd, 0x54,
			0x40, 0x00, 0x40, 0x06, 0x7e, 0xa5,
			0x7f, 0x00, 0x00, 0x01,
			0x7f, 0x00, 0x00, 0x01,
			// end of ipv4 header
			0x9d, 0xae, 0x19, 0xfd, 0x43, 0x05,
			0x1b, 0x87, 0x00, 0x00, 0x00, 0x00,
			0xa0, 0x02, 0xaa, 0xaa, 0xfe, 0x30,
			0x00, 0x00, 0x02, 0x04, 0xff, 0xd7,
			0x04, 0x02, 0x08, 0x0a, 0x3c, 0x2c,
			0xa6, 0xd3, 0x00, 0x00, 0x00, 0x00,
			0x01, 0x03, 0x03, 0x07
	};

	static uint8_t frame2[] = {
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
			0x08, 0x00, // end of ethernet header
			0x45, 0xc0, 0x00, 0x3c, 0xbd, 0x54,
			0x40, 0x00, 0x40, 0x06, 0x7e, 0xa5,
			0x7f, 0x00, 0x00, 0x01,
			0x7f, 0x00, 0x00, 0x01,
			// end of ipv4 header
			0x9d, 0xae, 0x19, 0xfd, 0x43, 0x05,
			0x1b, 0x87, 0x00, 0x00, 0x00, 0x00,
			0xa0, 0x02, 0xaa, 0xaa, 0xfe, 0x30,
			0x00, 0x00, 0x02, 0x04, 0xff, 0xd7,
			0x04, 0x02, 0x08, 0x0a, 0x3c, 0x2c,
			0xa6, 0xd3, 0x00, 0x00, 0x00, 0x00,
			0x01, 0x03, 0x03, 0x07
	};

	init_vlan_table();

	reset_output_frame_buffers();
	mac_load_frame(0, frame1, sizeof(frame1));
	process_model(0, &io);

	for (int i = 0; i < ETH_PORTS_NR; i++) {
		if (out_frames[i].frame.size)
			return 1;
	}

	reset_output_frame_buffers();
	mac_load_frame(0, frame2, sizeof(frame2));
	process_model(0, &io);

	for (int i = 0; i < ETH_PORTS_NR; i++) {
		if (i == 2 || i == 6)
			continue;

		if (out_frames[i].frame.size)
			return 1;
	}

	if (out_frames[6].frame.size != sizeof(frame2) ||
		memcmp(frame2, out_frames[6].frame.buf, sizeof(frame2)) != 0)
		return 1;

	if (out_frames[2].frame.size != sizeof(frame2) ||
		memcmp(frame2, out_frames[2].frame.buf, sizeof(frame2)) != 0)
		return 1;

	return 0;
}

int test_learn(struct output_frame_context *out_frames,
			   struct output_frame_context *ctrl_frame)
{
	static uint8_t frame1[] = {
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x81, 0x00, 0x00, 0x02, // vlan header
			0x08, 0x00, // end of ethernet header
			0x45, 0xc0, 0x00, 0x3c, 0xbd, 0x54,
			0x40, 0x00, 0x40, 0x06, 0x7e, 0xa5,
			0x7f, 0x00, 0x00, 0x01, // src_ip
			0x7f, 0x00, 0x00, 0x01, // dst_ip
			// end of ipv4 header
			0x9d, 0xae,
			0x19, 0xfd, 0x43, 0x05, 0x1b, 0x87,
			0x00, 0x00, 0x00, 0x00, 0xa0, 0x02,
			0xaa, 0xaa, 0xfe, 0x30, 0x00, 0x00,
			0x02, 0x04, 0xff, 0xd7, 0x04, 0x02,
			0x08, 0x0a, 0x3c, 0x2c, 0xa6, 0xd3,
			0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
			0x03, 0x07
	};

	static uint8_t frame1_untagged[] = {
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x08, 0x00, // end of ethernet header
			0x45, 0xc0, 0x00, 0x3c, 0xbd, 0x54,
			0x40, 0x00, 0x40, 0x06, 0x7e, 0xa5,
			0x7f, 0x00, 0x00, 0x01, // src_ip
			0x7f, 0x00, 0x00, 0x01, // dst_ip
			// end of ipv4 header
			0x9d, 0xae,
			0x19, 0xfd, 0x43, 0x05, 0x1b, 0x87,
			0x00, 0x00, 0x00, 0x00, 0xa0, 0x02,
			0xaa, 0xaa, 0xfe, 0x30, 0x00, 0x00,
			0x02, 0x04, 0xff, 0xd7, 0x04, 0x02,
			0x08, 0x0a, 0x3c, 0x2c, 0xa6, 0xd3,
			0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
			0x03, 0x07
	};

	static uint8_t frame2[] = {
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x81, 0x00, 0x00, 0x02, // vlan header
			0x08, 0x00, 0x45, 0xc0, 0x00, 0x3c,
			0xbd, 0x54, 0x40, 0x00, 0x40, 0x06,
			0x7e, 0xa5, 0x7f, 0x00, 0x00, 0x01,
			0x7f, 0x00, 0x00, 0x01, 0x9d, 0xae,
			0x19, 0xfd, 0x43, 0x05, 0x1b, 0x87,
			0x00, 0x00, 0x00, 0x00, 0xa0, 0x02,
			0xaa, 0xaa, 0xfe, 0x30, 0x00, 0x00,
			0x02, 0x04, 0xff, 0xd7, 0x04, 0x02,
			0x08, 0x0a, 0x3c, 0x2c, 0xa6, 0xd3,
			0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
			0x03, 0x07
	};

	static uint8_t frame2_untagged[] = {
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x08, 0x00, // end of ethernet header
			0x45, 0xc0, 0x00, 0x3c,
			0xbd, 0x54, 0x40, 0x00, 0x40, 0x06,
			0x7e, 0xa5, 0x7f, 0x00, 0x00, 0x01,
			0x7f, 0x00, 0x00, 0x01, 0x9d, 0xae,
			0x19, 0xfd, 0x43, 0x05, 0x1b, 0x87,
			0x00, 0x00, 0x00, 0x00, 0xa0, 0x02,
			0xaa, 0xaa, 0xfe, 0x30, 0x00, 0x00,
			0x02, 0x04, 0xff, 0xd7, 0x04, 0x02,
			0x08, 0x0a, 0x3c, 0x2c, 0xa6, 0xd3,
			0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
			0x03, 0x07
	};

	reset_output_frame_buffers();
	mac_load_frame(1, frame1, sizeof(frame1));
	process_model(1, &io);

	for (int i = 0; i < ETH_PORTS_NR; i++) {
		if (i == 3 || i == 4 || i == 5)
			continue;

		if (out_frames[i].frame.size)
			return 1;
	}

	if (out_frames[3].frame.size != sizeof(frame1_untagged) ||
		memcmp(frame1_untagged, out_frames[3].frame.buf,
			   sizeof(frame1_untagged)) != 0)
		return 1;

	if (out_frames[4].frame.size != sizeof(frame1) ||
		memcmp(frame1, out_frames[4].frame.buf, sizeof(frame1)) != 0)
		return 1;

	if (out_frames[5].frame.size != sizeof(frame1) ||
		memcmp(frame1, out_frames[5].frame.buf, sizeof(frame1)) != 0)
		return 1;

	struct learn_ctx lrn;
	struct ctrl_lrn_pkt *pkt = (void *) ctrl_frame->frame.buf;
	memcpy(lrn.src_mac.octets, pkt->mac, sizeof(lrn.src_mac.octets));
	lrn.src_port = pkt->port;
	lrn.vlan_tag = pkt->vlan_tag;
	lrn.src_hash = pkt->src_hash;
	learn(&lrn);

	reset_output_frame_buffers();
	mac_load_frame(5, frame2, sizeof(frame2));
	process_model(5, &io);

	for (int i = 0; i < ETH_PORTS_NR; i++) {
		if (i == 1)
			continue;

		if (out_frames[i].frame.size)
			return 1;
	}

	if (out_frames[1].frame.size != sizeof(frame2_untagged) ||
		memcmp(frame2_untagged, out_frames[1].frame.buf,
			   sizeof(frame2_untagged)) != 0)
		return 1;

	return 0;
}

int test_vlan(struct output_frame_context *out_frames,
			  struct output_frame_context *ctrl_frame)
{
	static uint8_t frame[] = {
			0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xf1, 0xff, 0xff, 0xff, 0xff, 0xff,
			0x81, 0x00, 0x30, 0x01, // vlan header
			0x08, 0x00, 0x45, 0xc0, 0x00, 0x3c,
			0xbd, 0x54, 0x40, 0x00, 0x40, 0x06,
			0x7e, 0xa5, 0x7f, 0x00, 0x00, 0x01,
			0x7f, 0x00, 0x00, 0x01, 0x9d, 0xae,
			0x19, 0xfd, 0x43, 0x05, 0x1b, 0x87,
			0x00, 0x00, 0x00, 0x00, 0xa0, 0x02,
			0xaa, 0xaa, 0xfe, 0x30, 0x00, 0x00,
			0x02, 0x04, 0xff, 0xd7, 0x04, 0x02,
			0x08, 0x0a, 0x3c, 0x2c, 0xa6, 0xd3,
			0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
			0x03, 0x07
	};

	static uint8_t frame_untagged[] = {
			0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xf1, 0xff, 0xff, 0xff, 0xff, 0xff,
			0x08, 0x00, 0x45, 0xc0, 0x00, 0x3c,
			0xbd, 0x54, 0x40, 0x00, 0x40, 0x06,
			0x7e, 0xa5, 0x7f, 0x00, 0x00, 0x01,
			0x7f, 0x00, 0x00, 0x01, 0x9d, 0xae,
			0x19, 0xfd, 0x43, 0x05, 0x1b, 0x87,
			0x00, 0x00, 0x00, 0x00, 0xa0, 0x02,
			0xaa, 0xaa, 0xfe, 0x30, 0x00, 0x00,
			0x02, 0x04, 0xff, 0xd7, 0x04, 0x02,
			0x08, 0x0a, 0x3c, 0x2c, 0xa6, 0xd3,
			0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
			0x03, 0x07
	};

	reset_output_frame_buffers();
	mac_load_frame(4, frame, sizeof(frame));
	process_model(4, &io);

	for (int i = 0; i < ETH_PORTS_NR; i++) {
		if (i == 0 || i == 5)
			continue;

		if (out_frames[i].frame.size)
			return 1;
	}

	if (out_frames[0].frame.size != sizeof(frame_untagged) ||
		memcmp(frame_untagged, out_frames[0].frame.buf,
			   sizeof(frame_untagged)) != 0)
		return 1;

	if (out_frames[5].frame.size != sizeof(frame) ||
		memcmp(frame, out_frames[5].frame.buf, sizeof(frame)) != 0)
		return 1;

	return 0;
}

int test_drop(struct output_frame_context *out_frames,
			  struct output_frame_context *ctrl_frame)
{
	static uint8_t frame[] = {
			0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xf1, 0xff, 0xff, 0xff, 0xff, 0xff,
			0x81, 0x00, 0x30, 0x03, // vlan header
			0x08, 0x00, 0x45, 0xc0, 0x00, 0x3c,
			0xbd, 0x54, 0x40, 0x00, 0x40, 0x06,
			0x7e, 0xa5, 0x7f, 0x00, 0x00, 0x01,
			0x7f, 0x00, 0x00, 0x01, 0x9d, 0xae,
			0x19, 0xfd, 0x43, 0x05, 0x1b, 0x87,
			0x00, 0x00, 0x00, 0x00, 0xa0, 0x02,
			0xaa, 0xaa, 0xfe, 0x30, 0x00, 0x00,
			0x02, 0x04, 0xff, 0xd7, 0x04, 0x02,
			0x08, 0x0a, 0x3c, 0x2c, 0xa6, 0xd3,
			0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
			0x03, 0x07
	};

	reset_output_frame_buffers();
	mac_load_frame(2, frame, sizeof(frame));
	process_model(2, &io);

	for (int i = 0; i < ETH_PORTS_NR; i++) {
		if (out_frames[i].frame.size)
			return 1;
	}

	return 0;
}
